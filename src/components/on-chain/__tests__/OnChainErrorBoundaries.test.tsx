/**
 * Tests for on-chain error boundary components
 * Tests error catching, fallback UI, and recovery mechanisms
 */\n\nimport React from 'react';\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport '@testing-library/jest-dom';\nimport {\n  OnChainErrorBoundary,\n  TransactionFetchErrorBoundary,\n  PriceFetchErrorBoundary,\n  TimelineErrorBoundary,\n  withErrorRecovery\n} from '../OnChainErrorBoundaries';\n\n// Mock console.error to avoid noise in tests\nconst originalConsoleError = console.error;\nbeforeAll(() => {\n  console.error = jest.fn();\n});\n\nafterAll(() => {\n  console.error = originalConsoleError;\n});\n\n// Mock window.open for external link tests\nconst mockWindowOpen = jest.fn();\nObject.defineProperty(window, 'open', {\n  value: mockWindowOpen,\n  writable: true\n});\n\n// Mock window.location.reload\nconst mockReload = jest.fn();\nObject.defineProperty(window, 'location', {\n  value: { reload: mockReload },\n  writable: true\n});\n\n// Component that throws an error for testing\nconst ThrowError = ({ shouldThrow = true, errorMessage = 'Test error' }: {\n  shouldThrow?: boolean;\n  errorMessage?: string;\n}) => {\n  if (shouldThrow) {\n    throw new Error(errorMessage);\n  }\n  return <div data-testid=\"success-component\">Success!</div>;\n};\n\ndescribe('OnChainErrorBoundary', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n\n  it('should render children when no error occurs', () => {\n    render(\n      <OnChainErrorBoundary>\n        <div data-testid=\"child-component\">Child Content</div>\n      </OnChainErrorBoundary>\n    );\n\n    expect(screen.getByTestId('child-component')).toBeInTheDocument();\n    expect(screen.getByText('Child Content')).toBeInTheDocument();\n  });\n\n  it('should display error fallback when child throws error', () => {\n    render(\n      <OnChainErrorBoundary>\n        <ThrowError shouldThrow={true} />\n      </OnChainErrorBoundary>\n    );\n\n    expect(screen.getByText('Tracker Error')).toBeInTheDocument();\n    expect(screen.getByText(/vesting tracker encountered an error/i)).toBeInTheDocument();\n    expect(screen.getByRole('button', { name: /try again/i })).toBeInTheDocument();\n    expect(screen.getByRole('button', { name: /refresh page/i })).toBeInTheDocument();\n  });\n\n  it('should call onRetry when Try Again button is clicked', () => {\n    const mockRetry = jest.fn();\n    \n    render(\n      <OnChainErrorBoundary onRetry={mockRetry}>\n        <ThrowError shouldThrow={true} />\n      </OnChainErrorBoundary>\n    );\n\n    const tryAgainButton = screen.getByRole('button', { name: /try again/i });\n    fireEvent.click(tryAgainButton);\n\n    expect(mockRetry).toHaveBeenCalledTimes(1);\n  });\n\n  it('should call window.location.reload when Refresh Page button is clicked', () => {\n    render(\n      <OnChainErrorBoundary>\n        <ThrowError shouldThrow={true} />\n      </OnChainErrorBoundary>\n    );\n\n    const refreshButton = screen.getByRole('button', { name: /refresh page/i });\n    fireEvent.click(refreshButton);\n\n    expect(mockReload).toHaveBeenCalledTimes(1);\n  });\n\n  it('should call window.location.reload when no onRetry is provided and Try Again is clicked', () => {\n    render(\n      <OnChainErrorBoundary>\n        <ThrowError shouldThrow={true} />\n      </OnChainErrorBoundary>\n    );\n\n    const tryAgainButton = screen.getByRole('button', { name: /try again/i });\n    fireEvent.click(tryAgainButton);\n\n    expect(mockReload).toHaveBeenCalledTimes(1);\n  });\n});\n\ndescribe('TransactionFetchErrorBoundary', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n\n  it('should render children when no error occurs', () => {\n    render(\n      <TransactionFetchErrorBoundary>\n        <div data-testid=\"child-component\">Child Content</div>\n      </TransactionFetchErrorBoundary>\n    );\n\n    expect(screen.getByTestId('child-component')).toBeInTheDocument();\n  });\n\n  it('should display transaction fetch error fallback', () => {\n    render(\n      <TransactionFetchErrorBoundary>\n        <ThrowError shouldThrow={true} />\n      </TransactionFetchErrorBoundary>\n    );\n\n    expect(screen.getByText('Transaction Fetch Failed')).toBeInTheDocument();\n    expect(screen.getByText(/unable to fetch transaction data/i)).toBeInTheDocument();\n    expect(screen.getByRole('button', { name: /check mempool\\.space/i })).toBeInTheDocument();\n  });\n\n  it('should call onRetry when Retry Fetch button is clicked', () => {\n    const mockRetry = jest.fn();\n    \n    render(\n      <TransactionFetchErrorBoundary onRetry={mockRetry}>\n        <ThrowError shouldThrow={true} />\n      </TransactionFetchErrorBoundary>\n    );\n\n    const retryButton = screen.getByRole('button', { name: /retry fetch/i });\n    fireEvent.click(retryButton);\n\n    expect(mockRetry).toHaveBeenCalledTimes(1);\n  });\n\n  it('should open mempool.space when Check Mempool button is clicked', () => {\n    render(\n      <TransactionFetchErrorBoundary>\n        <ThrowError shouldThrow={true} />\n      </TransactionFetchErrorBoundary>\n    );\n\n    const mempoolButton = screen.getByRole('button', { name: /check mempool\\.space/i });\n    fireEvent.click(mempoolButton);\n\n    expect(mockWindowOpen).toHaveBeenCalledWith('https://mempool.space', '_blank');\n  });\n\n  it('should not show retry button when onRetry is not provided', () => {\n    render(\n      <TransactionFetchErrorBoundary>\n        <ThrowError shouldThrow={true} />\n      </TransactionFetchErrorBoundary>\n    );\n\n    expect(screen.queryByRole('button', { name: /retry fetch/i })).not.toBeInTheDocument();\n    expect(screen.getByRole('button', { name: /check mempool\\.space/i })).toBeInTheDocument();\n  });\n});\n\ndescribe('PriceFetchErrorBoundary', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n\n  it('should render children when no error occurs', () => {\n    render(\n      <PriceFetchErrorBoundary>\n        <div data-testid=\"child-component\">Child Content</div>\n      </PriceFetchErrorBoundary>\n    );\n\n    expect(screen.getByTestId('child-component')).toBeInTheDocument();\n  });\n\n  it('should display price fetch error fallback with partial data option', () => {\n    render(\n      <PriceFetchErrorBoundary allowPartialData={true}>\n        <ThrowError shouldThrow={true} />\n      </PriceFetchErrorBoundary>\n    );\n\n    expect(screen.getByText('Price Data Unavailable')).toBeInTheDocument();\n    expect(screen.getByText(/historical price data could not be retrieved/i)).toBeInTheDocument();\n    expect(screen.getByRole('button', { name: /continue without prices/i })).toBeInTheDocument();\n  });\n\n  it('should display price fetch error fallback without partial data option', () => {\n    render(\n      <PriceFetchErrorBoundary allowPartialData={false}>\n        <ThrowError shouldThrow={true} />\n      </PriceFetchErrorBoundary>\n    );\n\n    expect(screen.getByText('Price Data Unavailable')).toBeInTheDocument();\n    expect(screen.getByText(/unable to fetch historical price data/i)).toBeInTheDocument();\n    expect(screen.queryByRole('button', { name: /continue without prices/i })).not.toBeInTheDocument();\n  });\n\n  it('should call onRetry when Retry Price Fetch button is clicked', () => {\n    const mockRetry = jest.fn();\n    \n    render(\n      <PriceFetchErrorBoundary onRetry={mockRetry}>\n        <ThrowError shouldThrow={true} />\n      </PriceFetchErrorBoundary>\n    );\n\n    const retryButton = screen.getByRole('button', { name: /retry price fetch/i });\n    fireEvent.click(retryButton);\n\n    expect(mockRetry).toHaveBeenCalledTimes(1);\n  });\n\n  it('should handle continue with partial data', () => {\n    // Mock console.log to capture the partial data continuation\n    const consoleSpy = jest.spyOn(console, 'log').mockImplementation();\n    \n    render(\n      <PriceFetchErrorBoundary allowPartialData={true}>\n        <ThrowError shouldThrow={true} />\n      </PriceFetchErrorBoundary>\n    );\n\n    const continueButton = screen.getByRole('button', { name: /continue without prices/i });\n    fireEvent.click(continueButton);\n\n    expect(consoleSpy).toHaveBeenCalledWith('Continuing with partial data...');\n    \n    consoleSpy.mockRestore();\n  });\n});\n\ndescribe('TimelineErrorBoundary', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n\n  it('should render children when no error occurs', () => {\n    render(\n      <TimelineErrorBoundary>\n        <div data-testid=\"child-component\">Child Content</div>\n      </TimelineErrorBoundary>\n    );\n\n    expect(screen.getByTestId('child-component')).toBeInTheDocument();\n  });\n\n  it('should display timeline error fallback with default message', () => {\n    render(\n      <TimelineErrorBoundary>\n        <ThrowError shouldThrow={true} />\n      </TimelineErrorBoundary>\n    );\n\n    expect(screen.getByText('Timeline Unavailable')).toBeInTheDocument();\n    expect(screen.getByText('Timeline visualization is currently unavailable')).toBeInTheDocument();\n    expect(screen.getByText(/data table below still shows/i)).toBeInTheDocument();\n  });\n\n  it('should display timeline error fallback with custom message', () => {\n    const customMessage = 'Custom timeline error message';\n    \n    render(\n      <TimelineErrorBoundary fallbackMessage={customMessage}>\n        <ThrowError shouldThrow={true} />\n      </TimelineErrorBoundary>\n    );\n\n    expect(screen.getByText('Timeline Unavailable')).toBeInTheDocument();\n    expect(screen.getByText(customMessage)).toBeInTheDocument();\n  });\n});\n\ndescribe('withErrorRecovery HOC', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n\n  it('should wrap component with default error boundary', () => {\n    const TestComponent = ({ message }: { message: string }) => (\n      <div data-testid=\"test-component\">{message}</div>\n    );\n    \n    const WrappedComponent = withErrorRecovery(TestComponent);\n    \n    render(<WrappedComponent message=\"Hello World\" />);\n    \n    expect(screen.getByTestId('test-component')).toBeInTheDocument();\n    expect(screen.getByText('Hello World')).toBeInTheDocument();\n  });\n\n  it('should catch errors in wrapped component', () => {\n    const ErrorComponent = withErrorRecovery(ThrowError);\n    \n    render(<ErrorComponent shouldThrow={true} />);\n    \n    expect(screen.getByText('Tracker Error')).toBeInTheDocument();\n  });\n\n  it('should use custom error boundary', () => {\n    const CustomErrorBoundary = ({ children }: { children: React.ReactNode }) => (\n      <div data-testid=\"custom-boundary\">{children}</div>\n    );\n    \n    const TestComponent = ({ message }: { message: string }) => (\n      <div data-testid=\"test-component\">{message}</div>\n    );\n    \n    const WrappedComponent = withErrorRecovery(TestComponent, CustomErrorBoundary);\n    \n    render(<WrappedComponent message=\"Hello World\" />);\n    \n    expect(screen.getByTestId('custom-boundary')).toBeInTheDocument();\n    expect(screen.getByTestId('test-component')).toBeInTheDocument();\n  });\n\n  it('should pass onRetry prop to error boundary', () => {\n    const mockRetry = jest.fn();\n    const ErrorComponent = withErrorRecovery(ThrowError);\n    \n    render(<ErrorComponent shouldThrow={true} onRetry={mockRetry} />);\n    \n    const tryAgainButton = screen.getByRole('button', { name: /try again/i });\n    fireEvent.click(tryAgainButton);\n    \n    expect(mockRetry).toHaveBeenCalledTimes(1);\n  });\n});\n\ndescribe('Error Boundary Integration', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n\n  it('should handle nested error boundaries correctly', () => {\n    const NestedComponent = () => {\n      throw new Error('Nested error');\n    };\n\n    render(\n      <OnChainErrorBoundary>\n        <TransactionFetchErrorBoundary>\n          <NestedComponent />\n        </TransactionFetchErrorBoundary>\n      </OnChainErrorBoundary>\n    );\n\n    // Inner boundary should catch the error first\n    expect(screen.getByText('Transaction Fetch Failed')).toBeInTheDocument();\n    expect(screen.queryByText('Tracker Error')).not.toBeInTheDocument();\n  });\n\n  it('should handle recovery flow correctly', async () => {\n    let shouldThrow = true;\n    const RecoverableComponent = () => {\n      if (shouldThrow) {\n        throw new Error('Temporary error');\n      }\n      return <div data-testid=\"recovered-component\">Recovered!</div>;\n    };\n\n    const mockRetry = jest.fn().mockImplementation(() => {\n      shouldThrow = false;\n    });\n\n    const { rerender } = render(\n      <OnChainErrorBoundary onRetry={mockRetry}>\n        <RecoverableComponent />\n      </OnChainErrorBoundary>\n    );\n\n    // Initially shows error\n    expect(screen.getByText('Tracker Error')).toBeInTheDocument();\n\n    // Click retry\n    const tryAgainButton = screen.getByRole('button', { name: /try again/i });\n    fireEvent.click(tryAgainButton);\n    \n    expect(mockRetry).toHaveBeenCalledTimes(1);\n\n    // Simulate component re-render after retry\n    rerender(\n      <OnChainErrorBoundary onRetry={mockRetry}>\n        <RecoverableComponent />\n      </OnChainErrorBoundary>\n    );\n\n    // Should still show error boundary since React error boundaries\n    // don't automatically retry - that's handled by parent component state\n    expect(screen.getByText('Tracker Error')).toBeInTheDocument();\n  });\n\n  it('should maintain accessibility attributes', () => {\n    render(\n      <OnChainErrorBoundary>\n        <ThrowError shouldThrow={true} />\n      </OnChainErrorBoundary>\n    );\n\n    const tryAgainButton = screen.getByRole('button', { name: /try again/i });\n    const refreshButton = screen.getByRole('button', { name: /refresh page/i });\n\n    // Check that buttons are properly accessible\n    expect(tryAgainButton).toHaveAttribute('type', 'button');\n    expect(refreshButton).toHaveAttribute('type', 'button');\n    \n    // Check that icons have aria-hidden\n    const icons = document.querySelectorAll('svg[aria-hidden=\"true\"]');\n    expect(icons.length).toBeGreaterThan(0);\n  });\n\n  it('should apply correct styling classes', () => {\n    render(\n      <OnChainErrorBoundary>\n        <ThrowError shouldThrow={true} />\n      </OnChainErrorBoundary>\n    );\n\n    // Check for proper styling classes\n    const errorContainer = screen.getByText('Tracker Error').closest('div');\n    expect(errorContainer).toHaveClass('bg-red-50');\n    expect(errorContainer).toHaveClass('border-red-200');\n  });\n});\n\ndescribe('Error Boundary Performance', () => {\n  it('should not re-render unnecessarily', () => {\n    const renderSpy = jest.fn();\n    \n    const TestComponent = () => {\n      renderSpy();\n      return <div data-testid=\"test-component\">Test</div>;\n    };\n\n    const { rerender } = render(\n      <OnChainErrorBoundary>\n        <TestComponent />\n      </OnChainErrorBoundary>\n    );\n\n    expect(renderSpy).toHaveBeenCalledTimes(1);\n\n    // Re-render with same props\n    rerender(\n      <OnChainErrorBoundary>\n        <TestComponent />\n      </OnChainErrorBoundary>\n    );\n\n    expect(renderSpy).toHaveBeenCalledTimes(2);\n  });\n\n  it('should handle multiple rapid errors gracefully', () => {\n    const MultiErrorComponent = ({ errorCount }: { errorCount: number }) => {\n      if (errorCount > 0) {\n        throw new Error(`Error ${errorCount}`);\n      }\n      return <div>No error</div>;\n    };\n\n    const { rerender } = render(\n      <OnChainErrorBoundary>\n        <MultiErrorComponent errorCount={0} />\n      </OnChainErrorBoundary>\n    );\n\n    // Trigger multiple errors\n    rerender(\n      <OnChainErrorBoundary>\n        <MultiErrorComponent errorCount={1} />\n      </OnChainErrorBoundary>\n    );\n\n    expect(screen.getByText('Tracker Error')).toBeInTheDocument();\n\n    rerender(\n      <OnChainErrorBoundary>\n        <MultiErrorComponent errorCount={2} />\n      </OnChainErrorBoundary>\n    );\n\n    // Should still show error boundary\n    expect(screen.getByText('Tracker Error')).toBeInTheDocument();\n  });\n});\n