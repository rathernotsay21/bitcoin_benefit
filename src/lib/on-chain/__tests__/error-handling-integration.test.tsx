/**\n * Integration tests for comprehensive on-chain error handling and recovery\n * Tests complete error flow from user input to error resolution\n */\n\nimport React from 'react';\nimport { render, screen, fireEvent, waitFor, act } from '@testing-library/react';\nimport '@testing-library/jest-dom';\nimport { useOnChainStore } from '@/stores/onChainStore';\nimport OnChainTrackerPage from '@/app/on-chain/page';\nimport { MempoolAPIError } from '@/lib/on-chain/mempool-api';\nimport { OnChainTrackingError } from '@/lib/on-chain/error-handler';\n\n// Mock the store\njest.mock('@/stores/onChainStore');\nconst mockUseOnChainStore = useOnChainStore as jest.MockedFunction<typeof useOnChainStore>;\n\n// Mock Navigation component\njest.mock('@/components/Navigation', () => {\n  return function MockNavigation() {\n    return <div data-testid=\"navigation\">Navigation</div>;\n  };\n});\n\n// Mock the icon components\njest.mock('@heroicons/react/24/outline', () => ({\n  ShieldCheckIcon: ({ className, ...props }: any) => (\n    <svg className={className} data-testid=\"shield-icon\" {...props}>\n      <path d=\"shield\" />\n    </svg>\n  ),\n  InformationCircleIcon: ({ className, ...props }: any) => (\n    <svg className={className} data-testid=\"info-icon\" {...props}>\n      <path d=\"info\" />\n    </svg>\n  ),\n  ChartBarIcon: ({ className, ...props }: any) => (\n    <svg className={className} data-testid=\"chart-icon\" {...props}>\n      <path d=\"chart\" />\n    </svg>\n  ),\n  ClockIcon: ({ className, ...props }: any) => (\n    <svg className={className} data-testid=\"clock-icon\" {...props}>\n      <path d=\"clock\" />\n    </svg>\n  ),\n  ExclamationTriangleIcon: ({ className, ...props }: any) => (\n    <svg className={className} data-testid=\"warning-icon\" {...props}>\n      <path d=\"warning\" />\n    </svg>\n  )\n}));\n\n// Mock the on-chain components\njest.mock('@/components/on-chain/VestingTrackerForm', () => {\n  return function MockVestingTrackerForm({ onSubmit }: any) {\n    return (\n      <div data-testid=\"vesting-tracker-form\">\n        <button\n          data-testid=\"submit-form\"\n          onClick={() => onSubmit({\n            address: 'test-address',\n            vestingStartDate: '2020-01-01',\n            annualGrantBtc: 1.0\n          })}\n        >\n          Submit Form\n        </button>\n      </div>\n    );\n  };\n});\n\njest.mock('@/components/on-chain/VestingTrackerResults', () => {\n  return function MockVestingTrackerResults({ \n    transactions, \n    error, \n    onRetry, \n    partialDataAvailable, \n    onContinueWithPartialData \n  }: any) {\n    if (error) {\n      return (\n        <div data-testid=\"results-error\">\n          <p>{error}</p>\n          <button data-testid=\"retry-results\" onClick={onRetry}>\n            Retry Results\n          </button>\n        </div>\n      );\n    }\n\n    if (partialDataAvailable) {\n      return (\n        <div data-testid=\"partial-data-results\">\n          <p>Partial data available</p>\n          <button data-testid=\"continue-partial\" onClick={onContinueWithPartialData}>\n            Continue with Partial Data\n          </button>\n        </div>\n      );\n    }\n\n    return (\n      <div data-testid=\"transaction-results\">\n        <p>Transactions: {transactions.length}</p>\n      </div>\n    );\n  };\n});\n\njest.mock('@/components/on-chain/OnChainTimelineVisualizer', () => {\n  return function MockOnChainTimelineVisualizer() {\n    return <div data-testid=\"timeline-visualizer\">Timeline Chart</div>;\n  };\n});\n\n// Mock window.open\nconst mockWindowOpen = jest.fn();\nObject.defineProperty(window, 'open', {\n  value: mockWindowOpen,\n  writable: true\n});\n\ndescribe('OnChain Error Handling Integration', () => {\n  // Default mock store state\n  const defaultMockState = {\n    address: '',\n    vestingStartDate: '',\n    annualGrantBtc: 0,\n    annotatedTransactions: [],\n    expectedGrants: [],\n    manualAnnotations: new Map(),\n    isLoading: false,\n    error: null,\n    currentStep: 'idle' as const,\n    formErrors: {},\n    partialDataAvailable: false,\n    lastError: null,\n    retryCount: 0,\n    setFormData: jest.fn(),\n    validateAndFetch: jest.fn(),\n    updateManualAnnotation: jest.fn(),\n    resetTracker: jest.fn(),\n    retryOperation: jest.fn(),\n    continueWithPartialData: jest.fn(),\n    clearError: jest.fn()\n  };\n\n  beforeEach(() => {\n    jest.clearAllMocks();\n    mockUseOnChainStore.mockReturnValue(defaultMockState);\n  });\n\n  describe('Error Display and Recovery', () => {\n    it('should display network error with appropriate recovery options', async () => {\n      const mockState = {\n        ...defaultMockState,\n        error: 'Network connection failed. Please check your connection and try again.',\n        isLoading: false,\n        retryCount: 1\n      };\n      mockUseOnChainStore.mockReturnValue(mockState);\n\n      render(<OnChainTrackerPage />);\n\n      expect(screen.getByText('Connection Error')).toBeInTheDocument();\n      expect(screen.getByText(/Network connection failed/)).toBeInTheDocument();\n      expect(screen.getByText('Retry attempt: 1')).toBeInTheDocument();\n      \n      // Should have Try Again button\n      expect(screen.getByRole('button', { name: /try again/i })).toBeInTheDocument();\n      \n      // Should have Check Mempool.space button for network errors\n      expect(screen.getByRole('button', { name: /check mempool\\.space/i })).toBeInTheDocument();\n      \n      // Should have Reset button\n      expect(screen.getByRole('button', { name: /reset/i })).toBeInTheDocument();\n    });\n\n    it('should display validation error without external service buttons', async () => {\n      const mockState = {\n        ...defaultMockState,\n        error: 'Invalid Bitcoin address format',\n        isLoading: false\n      };\n      mockUseOnChainStore.mockReturnValue(mockState);\n\n      render(<OnChainTrackerPage />);\n\n      expect(screen.getByText('Invalid Input')).toBeInTheDocument();\n      expect(screen.getByText('Invalid Bitcoin address format')).toBeInTheDocument();\n      \n      // Should have Try Again button\n      expect(screen.getByRole('button', { name: /try again/i })).toBeInTheDocument();\n      \n      // Should NOT have Check Mempool.space button for validation errors\n      expect(screen.queryByRole('button', { name: /check mempool\\.space/i })).not.toBeInTheDocument();\n      \n      // Should have Reset button\n      expect(screen.getByRole('button', { name: /reset/i })).toBeInTheDocument();\n    });\n\n    it('should handle retry operation with error clearing', async () => {\n      const mockClearError = jest.fn();\n      const mockRetryOperation = jest.fn();\n      \n      const mockState = {\n        ...defaultMockState,\n        error: 'Network error',\n        clearError: mockClearError,\n        retryOperation: mockRetryOperation\n      };\n      mockUseOnChainStore.mockReturnValue(mockState);\n\n      render(<OnChainTrackerPage />);\n\n      const retryButton = screen.getByRole('button', { name: /try again/i });\n      fireEvent.click(retryButton);\n\n      expect(mockClearError).toHaveBeenCalledTimes(1);\n      expect(mockRetryOperation).toHaveBeenCalledTimes(1);\n    });\n\n    it('should open external link when checking Mempool.space', async () => {\n      const mockState = {\n        ...defaultMockState,\n        error: 'Network timeout occurred'\n      };\n      mockUseOnChainStore.mockReturnValue(mockState);\n\n      render(<OnChainTrackerPage />);\n\n      const mempoolButton = screen.getByRole('button', { name: /check mempool\\.space/i });\n      fireEvent.click(mempoolButton);\n\n      expect(mockWindowOpen).toHaveBeenCalledWith('https://mempool.space', '_blank');\n    });\n\n    it('should handle reset tracker operation', async () => {\n      const mockResetTracker = jest.fn();\n      \n      const mockState = {\n        ...defaultMockState,\n        error: 'Some error',\n        resetTracker: mockResetTracker\n      };\n      mockUseOnChainStore.mockReturnValue(mockState);\n\n      render(<OnChainTrackerPage />);\n\n      const resetButton = screen.getByRole('button', { name: /reset/i });\n      fireEvent.click(resetButton);\n\n      expect(mockResetTracker).toHaveBeenCalledTimes(1);\n    });\n  });\n\n  describe('Partial Data Handling', () => {\n    it('should display partial data notice with continuation options', async () => {\n      const mockState = {\n        ...defaultMockState,\n        partialDataAvailable: true,\n        annotatedTransactions: [{\n          txid: 'test-tx',\n          grantYear: 1,\n          type: 'Annual Grant',\n          amountBTC: 1.0,\n          date: '2020-01-01',\n          isManuallyAnnotated: false,\n          valueAtTimeOfTx: null\n        }]\n      };\n      mockUseOnChainStore.mockReturnValue(mockState);\n\n      render(<OnChainTrackerPage />);\n\n      expect(screen.getByText('Partial Data Available')).toBeInTheDocument();\n      expect(screen.getByText(/transaction data was retrieved successfully/)).toBeInTheDocument();\n      \n      // Should have both continuation options\n      expect(screen.getByRole('button', { name: /continue with partial data/i })).toBeInTheDocument();\n      expect(screen.getByRole('button', { name: /retry price fetch/i })).toBeInTheDocument();\n    });\n\n    it('should handle continue with partial data', async () => {\n      const mockContinueWithPartialData = jest.fn();\n      \n      const mockState = {\n        ...defaultMockState,\n        partialDataAvailable: true,\n        continueWithPartialData: mockContinueWithPartialData\n      };\n      mockUseOnChainStore.mockReturnValue(mockState);\n\n      render(<OnChainTrackerPage />);\n\n      const continueButton = screen.getByRole('button', { name: /continue with partial data/i });\n      fireEvent.click(continueButton);\n\n      expect(mockContinueWithPartialData).toHaveBeenCalledTimes(1);\n    });\n\n    it('should handle retry price fetch from partial data state', async () => {\n      const mockClearError = jest.fn();\n      const mockRetryOperation = jest.fn();\n      \n      const mockState = {\n        ...defaultMockState,\n        partialDataAvailable: true,\n        clearError: mockClearError,\n        retryOperation: mockRetryOperation\n      };\n      mockUseOnChainStore.mockReturnValue(mockState);\n\n      render(<OnChainTrackerPage />);\n\n      const retryButton = screen.getByRole('button', { name: /retry price fetch/i });\n      fireEvent.click(retryButton);\n\n      expect(mockClearError).toHaveBeenCalledTimes(1);\n      expect(mockRetryOperation).toHaveBeenCalledTimes(1);\n    });\n  });\n\n  describe('Loading States and Progress', () => {\n    it('should display loading steps during processing', async () => {\n      const mockState = {\n        ...defaultMockState,\n        isLoading: true,\n        currentStep: 'fetching' as const\n      };\n      mockUseOnChainStore.mockReturnValue(mockState);\n\n      render(<OnChainTrackerPage />);\n\n      expect(screen.getByText('Processing Your Data')).toBeInTheDocument();\n      expect(screen.getByText('Fetching Transactions')).toBeInTheDocument();\n      expect(screen.getByText('Fetching transaction data from blockchain...')).toBeInTheDocument();\n    });\n\n    it('should show different loading steps based on current step', async () => {\n      // Test annotation step\n      let mockState = {\n        ...defaultMockState,\n        isLoading: true,\n        currentStep: 'annotating' as const\n      };\n      const { rerender } = render(<OnChainTrackerPage />);\n      mockUseOnChainStore.mockReturnValue(mockState);\n      rerender(<OnChainTrackerPage />);\n\n      expect(screen.getByText('Analyzing & Matching')).toBeInTheDocument();\n      expect(screen.getByText('Analyzing transactions and matching to vesting schedule...')).toBeInTheDocument();\n\n      // Test pricing step\n      mockState = {\n        ...defaultMockState,\n        isLoading: true,\n        currentStep: 'pricing' as const\n      };\n      mockUseOnChainStore.mockReturnValue(mockState);\n      rerender(<OnChainTrackerPage />);\n\n      expect(screen.getByText('Retrieving Prices')).toBeInTheDocument();\n      expect(screen.getByText('Retrieving historical Bitcoin prices...')).toBeInTheDocument();\n    });\n  });\n\n  describe('Results Display and Error Boundaries', () => {\n    it('should display transaction results when available', async () => {\n      const mockState = {\n        ...defaultMockState,\n        annotatedTransactions: [\n          {\n            txid: 'test-tx-1',\n            grantYear: 1,\n            type: 'Annual Grant',\n            amountBTC: 1.0,\n            date: '2020-01-01',\n            isManuallyAnnotated: false,\n            valueAtTimeOfTx: 50000\n          }\n        ],\n        expectedGrants: [\n          {\n            grantYear: 1,\n            expectedDate: '2020-01-01',\n            expectedAmountBTC: 1.0,\n            actualAmountBTC: 1.0,\n            status: 'fulfilled' as const\n          }\n        ],\n        currentStep: 'complete' as const\n      };\n      mockUseOnChainStore.mockReturnValue(mockState);\n\n      render(<OnChainTrackerPage />);\n\n      expect(screen.getByTestId('transaction-results')).toBeInTheDocument();\n      expect(screen.getByText('Transactions: 1')).toBeInTheDocument();\n      expect(screen.getByTestId('timeline-visualizer')).toBeInTheDocument();\n    });\n\n    it('should display results error with retry functionality', async () => {\n      const mockRetryOperation = jest.fn();\n      const mockClearError = jest.fn();\n      \n      const mockState = {\n        ...defaultMockState,\n        annotatedTransactions: [],\n        error: 'Failed to load transaction data',\n        retryOperation: mockRetryOperation,\n        clearError: mockClearError\n      };\n      mockUseOnChainStore.mockReturnValue(mockState);\n\n      render(<OnChainTrackerPage />);\n\n      expect(screen.getByTestId('results-error')).toBeInTheDocument();\n      expect(screen.getByText('Failed to load transaction data')).toBeInTheDocument();\n      \n      const retryButton = screen.getByTestId('retry-results');\n      fireEvent.click(retryButton);\n      \n      expect(mockClearError).toHaveBeenCalledTimes(1);\n      expect(mockRetryOperation).toHaveBeenCalledTimes(1);\n    });\n  });\n\n  describe('Complete Error Recovery Flow', () => {\n    it('should handle complete error-to-success flow', async () => {\n      const mockSetFormData = jest.fn();\n      const mockValidateAndFetch = jest.fn();\n      const mockClearError = jest.fn();\n      const mockRetryOperation = jest.fn();\n      \n      // Start with error state\n      let mockState = {\n        ...defaultMockState,\n        error: 'Network connection failed',\n        setFormData: mockSetFormData,\n        validateAndFetch: mockValidateAndFetch,\n        clearError: mockClearError,\n        retryOperation: mockRetryOperation\n      };\n      mockUseOnChainStore.mockReturnValue(mockState);\n\n      const { rerender } = render(<OnChainTrackerPage />);\n\n      // Should show error state\n      expect(screen.getByText('Connection Error')).toBeInTheDocument();\n      \n      // Click retry\n      const retryButton = screen.getByRole('button', { name: /try again/i });\n      fireEvent.click(retryButton);\n      \n      expect(mockClearError).toHaveBeenCalledTimes(1);\n      expect(mockRetryOperation).toHaveBeenCalledTimes(1);\n\n      // Simulate transition to loading state\n      mockState = {\n        ...defaultMockState,\n        isLoading: true,\n        currentStep: 'fetching' as const,\n        error: null,\n        setFormData: mockSetFormData,\n        validateAndFetch: mockValidateAndFetch,\n        clearError: mockClearError,\n        retryOperation: mockRetryOperation\n      };\n      mockUseOnChainStore.mockReturnValue(mockState);\n      rerender(<OnChainTrackerPage />);\n\n      // Should show loading state\n      expect(screen.getByText('Processing Your Data')).toBeInTheDocument();\n      expect(screen.getByText('Fetching Transactions')).toBeInTheDocument();\n\n      // Simulate successful completion\n      mockState = {\n        ...defaultMockState,\n        isLoading: false,\n        currentStep: 'complete' as const,\n        error: null,\n        annotatedTransactions: [\n          {\n            txid: 'test-tx-1',\n            grantYear: 1,\n            type: 'Annual Grant',\n            amountBTC: 1.0,\n            date: '2020-01-01',\n            isManuallyAnnotated: false,\n            valueAtTimeOfTx: 50000\n          }\n        ],\n        expectedGrants: [\n          {\n            grantYear: 1,\n            expectedDate: '2020-01-01',\n            expectedAmountBTC: 1.0,\n            actualAmountBTC: 1.0,\n            status: 'fulfilled' as const\n          }\n        ],\n        setFormData: mockSetFormData,\n        validateAndFetch: mockValidateAndFetch,\n        clearError: mockClearError,\n        retryOperation: mockRetryOperation\n      };\n      mockUseOnChainStore.mockReturnValue(mockState);\n      rerender(<OnChainTrackerPage />);\n\n      // Should show successful results\n      expect(screen.getByTestId('transaction-results')).toBeInTheDocument();\n      expect(screen.getByText('Transactions: 1')).toBeInTheDocument();\n      expect(screen.getByText('Analysis Summary')).toBeInTheDocument();\n    });\n\n    it('should handle form submission with error handling', async () => {\n      const mockSetFormData = jest.fn();\n      const mockValidateAndFetch = jest.fn();\n      \n      const mockState = {\n        ...defaultMockState,\n        setFormData: mockSetFormData,\n        validateAndFetch: mockValidateAndFetch\n      };\n      mockUseOnChainStore.mockReturnValue(mockState);\n\n      render(<OnChainTrackerPage />);\n\n      // Submit form\n      const submitButton = screen.getByTestId('submit-form');\n      fireEvent.click(submitButton);\n\n      expect(mockSetFormData).toHaveBeenCalledWith({\n        address: 'test-address',\n        vestingStartDate: '2020-01-01',\n        annualGrantBtc: 1.0\n      });\n      expect(mockValidateAndFetch).toHaveBeenCalledTimes(1);\n    });\n\n    it('should handle multiple error types in sequence', async () => {\n      const mockClearError = jest.fn();\n      const mockRetryOperation = jest.fn();\n      const mockContinueWithPartialData = jest.fn();\n      \n      // Start with network error\n      let mockState = {\n        ...defaultMockState,\n        error: 'Network timeout',\n        clearError: mockClearError,\n        retryOperation: mockRetryOperation,\n        continueWithPartialData: mockContinueWithPartialData\n      };\n      mockUseOnChainStore.mockReturnValue(mockState);\n\n      const { rerender } = render(<OnChainTrackerPage />);\n\n      expect(screen.getByText('Connection Error')).toBeInTheDocument();\n      \n      // Transition to partial data state\n      mockState = {\n        ...defaultMockState,\n        error: null,\n        partialDataAvailable: true,\n        annotatedTransactions: [{\n          txid: 'test-tx',\n          grantYear: 1,\n          type: 'Annual Grant',\n          amountBTC: 1.0,\n          date: '2020-01-01',\n          isManuallyAnnotated: false,\n          valueAtTimeOfTx: null\n        }],\n        clearError: mockClearError,\n        retryOperation: mockRetryOperation,\n        continueWithPartialData: mockContinueWithPartialData\n      };\n      mockUseOnChainStore.mockReturnValue(mockState);\n      rerender(<OnChainTrackerPage />);\n\n      expect(screen.getByText('Partial Data Available')).toBeInTheDocument();\n      \n      // Continue with partial data\n      const continueButton = screen.getByRole('button', { name: /continue with partial data/i });\n      fireEvent.click(continueButton);\n      \n      expect(mockContinueWithPartialData).toHaveBeenCalledTimes(1);\n    });\n  });\n\n  describe('Feature Overview and Initial State', () => {\n    it('should display feature overview when no results are available', async () => {\n      const mockState = {\n        ...defaultMockState,\n        currentStep: 'idle' as const,\n        annotatedTransactions: []\n      };\n      mockUseOnChainStore.mockReturnValue(mockState);\n\n      render(<OnChainTrackerPage />);\n\n      expect(screen.getByText('Verify Your Bitcoin Vesting History')).toBeInTheDocument();\n      expect(screen.getByText('Automatic Matching')).toBeInTheDocument();\n      expect(screen.getByText('Manual Overrides')).toBeInTheDocument();\n      expect(screen.getByText('Historical Values')).toBeInTheDocument();\n      expect(screen.getByText('Visual Timeline')).toBeInTheDocument();\n      expect(screen.getByText('Privacy Focused')).toBeInTheDocument();\n      expect(screen.getByText('Real-time Updates')).toBeInTheDocument();\n    });\n\n    it('should display privacy disclaimer with expandable details', async () => {\n      render(<OnChainTrackerPage />);\n\n      expect(screen.getByText('Privacy & Data Usage Notice')).toBeInTheDocument();\n      expect(screen.getByText('Data Transmission')).toBeInTheDocument();\n      expect(screen.getByText('No Data Storage')).toBeInTheDocument();\n      \n      // Should have expandable details\n      const expandButton = screen.getByRole('button', { name: /read full privacy details/i });\n      fireEvent.click(expandButton);\n      \n      expect(screen.getByText('Recommended Privacy Practices')).toBeInTheDocument();\n      expect(screen.getByText('External API Usage')).toBeInTheDocument();\n      expect(screen.getByText('Session-Only Processing')).toBeInTheDocument();\n      \n      // Should be able to collapse\n      const collapseButton = screen.getByRole('button', { name: /show less/i });\n      fireEvent.click(collapseButton);\n      \n      expect(screen.queryByText('Recommended Privacy Practices')).not.toBeInTheDocument();\n    });\n  });\n});\n