/**\n * Comprehensive tests for on-chain error handling and recovery\n * Tests error scenarios, retry logic, and recovery mechanisms\n */\n\nimport { \n  OnChainErrorHandler, \n  OnChainTrackingError,\n  NetworkError,\n  ValidationError,\n  DataProcessingError,\n  PartialDataError,\n  ErrorUtils\n} from '../error-handler';\nimport { MempoolAPIError } from '../mempool-api';\n\n// Mock console.error to avoid noise in tests\nconst originalConsoleError = console.error;\nbeforeAll(() => {\n  console.error = jest.fn();\n});\n\nafterAll(() => {\n  console.error = originalConsoleError;\n});\n\ndescribe('OnChainErrorHandler', () => {\n  let errorHandler: OnChainErrorHandler;\n\n  beforeEach(() => {\n    errorHandler = OnChainErrorHandler.getInstance();\n  });\n\n  describe('Error Processing', () => {\n    const mockContext = {\n      operation: 'test_operation',\n      step: 'test_step',\n      timestamp: '2024-01-01T00:00:00.000Z'\n    };\n\n    it('should process MempoolAPIError correctly', () => {\n      const mempoolError = new MempoolAPIError(\n        'Invalid Bitcoin address format',\n        400,\n        false\n      );\n      \n      const processed = errorHandler.processError(mempoolError, mockContext);\n      \n      expect(processed).toBeInstanceOf(ValidationError);\n      expect(processed.code).toBe('VALIDATION_ERROR');\n      expect(processed.isRetryable).toBe(false);\n      expect(processed.userFriendlyMessage).toContain('Invalid Bitcoin address');\n    });\n\n    it('should process network timeout errors', () => {\n      const timeoutError = new MempoolAPIError(\n        'Request timeout',\n        408,\n        true\n      );\n      \n      const processed = errorHandler.processError(timeoutError, mockContext);\n      \n      expect(processed).toBeInstanceOf(NetworkError);\n      expect(processed.code).toBe('NETWORK_ERROR');\n      expect(processed.isRetryable).toBe(true);\n    });\n\n    it('should process rate limit errors', () => {\n      const rateLimitError = new MempoolAPIError(\n        'Rate limit exceeded',\n        429,\n        true\n      );\n      \n      const processed = errorHandler.processError(rateLimitError, mockContext);\n      \n      expect(processed).toBeInstanceOf(NetworkError);\n      expect(processed.code).toBe('NETWORK_ERROR');\n      expect(processed.isRetryable).toBe(true);\n    });\n\n    it('should process server errors as retryable', () => {\n      const serverError = new MempoolAPIError(\n        'Internal server error',\n        500,\n        false\n      );\n      \n      const processed = errorHandler.processError(serverError, mockContext);\n      \n      expect(processed).toBeInstanceOf(NetworkError);\n      expect(processed.isRetryable).toBe(true);\n    });\n\n    it('should process generic fetch errors', () => {\n      const fetchError = new TypeError('Failed to fetch');\n      \n      const processed = errorHandler.processError(fetchError, mockContext);\n      \n      expect(processed).toBeInstanceOf(NetworkError);\n      expect(processed.isRetryable).toBe(true);\n      expect(processed.userFriendlyMessage).toBe('Network connection failed');\n    });\n\n    it('should process JSON parsing errors', () => {\n      const jsonError = new SyntaxError('Unexpected token in JSON');\n      \n      const processed = errorHandler.processError(jsonError, mockContext);\n      \n      expect(processed).toBeInstanceOf(DataProcessingError);\n      expect(processed.code).toBe('DATA_PROCESSING_ERROR');\n      expect(processed.isRetryable).toBe(false);\n    });\n\n    it('should process unknown errors', () => {\n      const unknownError = 'some string error';\n      \n      const processed = errorHandler.processError(unknownError, mockContext);\n      \n      expect(processed).toBeInstanceOf(OnChainTrackingError);\n      expect(processed.code).toBe('UNKNOWN_ERROR');\n      expect(processed.isRetryable).toBe(false);\n    });\n  });\n\n  describe('Retry Logic', () => {\n    it('should retry retryable operations', async () => {\n      let callCount = 0;\n      const operation = jest.fn().mockImplementation(() => {\n        callCount++;\n        if (callCount < 3) {\n          throw new NetworkError('Network error', 503);\n        }\n        return 'success';\n      });\n\n      const result = await errorHandler.executeWithRetry(\n        operation,\n        {\n          operation: 'transaction_fetch',\n          step: 'fetch_data',\n          timestamp: '2024-01-01T00:00:00.000Z'\n        },\n        {\n          maxRetries: 3,\n          baseDelay: 10, // Short delay for tests\n          maxDelay: 100,\n          exponentialBackoff: false,\n          retryableErrors: ['NETWORK_ERROR']\n        }\n      );\n\n      expect(result).toBe('success');\n      expect(operation).toHaveBeenCalledTimes(3);\n    });\n\n    it('should not retry non-retryable errors', async () => {\n      const operation = jest.fn().mockImplementation(() => {\n        throw new ValidationError('Invalid input');\n      });\n\n      await expect(errorHandler.executeWithRetry(\n        operation,\n        {\n          operation: 'validation',\n          step: 'validate_input',\n          timestamp: '2024-01-01T00:00:00.000Z'\n        },\n        {\n          maxRetries: 3,\n          baseDelay: 10,\n          maxDelay: 100,\n          exponentialBackoff: false,\n          retryableErrors: ['NETWORK_ERROR']\n        }\n      )).rejects.toThrow(ValidationError);\n\n      expect(operation).toHaveBeenCalledTimes(1);\n    });\n\n    it('should respect max retry limit', async () => {\n      const operation = jest.fn().mockImplementation(() => {\n        throw new NetworkError('Persistent network error', 503);\n      });\n\n      await expect(errorHandler.executeWithRetry(\n        operation,\n        {\n          operation: 'transaction_fetch',\n          step: 'fetch_data',\n          timestamp: '2024-01-01T00:00:00.000Z'\n        },\n        {\n          maxRetries: 2,\n          baseDelay: 10,\n          maxDelay: 100,\n          exponentialBackoff: false,\n          retryableErrors: ['NETWORK_ERROR']\n        }\n      )).rejects.toThrow(NetworkError);\n\n      expect(operation).toHaveBeenCalledTimes(3); // Initial call + 2 retries\n    });\n\n    it('should use exponential backoff when enabled', async () => {\n      let callCount = 0;\n      const startTime = Date.now();\n      const operation = jest.fn().mockImplementation(() => {\n        callCount++;\n        if (callCount < 3) {\n          throw new NetworkError('Network error', 503);\n        }\n        return 'success';\n      });\n\n      await errorHandler.executeWithRetry(\n        operation,\n        {\n          operation: 'transaction_fetch',\n          step: 'fetch_data',\n          timestamp: '2024-01-01T00:00:00.000Z'\n        },\n        {\n          maxRetries: 2,\n          baseDelay: 50,\n          maxDelay: 200,\n          exponentialBackoff: true,\n          retryableErrors: ['NETWORK_ERROR']\n        }\n      );\n\n      const endTime = Date.now();\n      const totalTime = endTime - startTime;\n      \n      // Should take at least baseDelay * 2 (exponential backoff)\n      // Plus some time for jitter\n      expect(totalTime).toBeGreaterThan(50);\n    });\n  });\n\n  describe('Partial Data Handling', () => {\n    it('should handle partial data scenarios', () => {\n      const availableData = { transactions: [{ id: '1' }] };\n      const missingData = 'historical prices';\n      const context = {\n        operation: 'price_fetch',\n        step: 'fetch_prices',\n        timestamp: '2024-01-01T00:00:00.000Z'\n      };\n\n      const result = errorHandler.handlePartialDataError(\n        availableData,\n        missingData,\n        context\n      );\n\n      expect(result.data).toEqual(availableData);\n      expect(result.error).toBeInstanceOf(PartialDataError);\n      expect(result.error.code).toBe('PARTIAL_DATA_ERROR');\n      expect(result.error.isRetryable).toBe(true);\n    });\n  });\n\n  describe('User-Friendly Error Messages', () => {\n    it('should create validation error messages', () => {\n      const validationError = new ValidationError('Invalid Bitcoin address', 'address');\n      \n      const userFriendly = errorHandler.createUserFriendlyError(validationError);\n      \n      expect(userFriendly.title).toBe('Invalid Input');\n      expect(userFriendly.canRetry).toBe(false);\n      expect(userFriendly.actionable).toContain('correct');\n    });\n\n    it('should create network error messages', () => {\n      const networkError = new NetworkError('Connection failed', 503);\n      \n      const userFriendly = errorHandler.createUserFriendlyError(networkError);\n      \n      expect(userFriendly.title).toBe('Connection Error');\n      expect(userFriendly.canRetry).toBe(true);\n      expect(userFriendly.actionable).toContain('try again');\n    });\n\n    it('should create partial data error messages', () => {\n      const partialError = new PartialDataError(\n        'Some data missing',\n        'transaction data',\n        'price data'\n      );\n      \n      const userFriendly = errorHandler.createUserFriendlyError(partialError);\n      \n      expect(userFriendly.title).toBe('Partial Results');\n      expect(userFriendly.canRetry).toBe(true);\n      expect(userFriendly.actionable).toContain('continue with partial data');\n    });\n  });\n});\n\ndescribe('Error Utility Functions', () => {\n  describe('ErrorUtils', () => {\n    it('should identify service unavailable errors', () => {\n      const serviceError = new NetworkError('Service unavailable', 503);\n      expect(ErrorUtils.isServiceUnavailable(serviceError)).toBe(true);\n\n      const otherError = new NetworkError('Timeout', 408);\n      expect(ErrorUtils.isServiceUnavailable(otherError)).toBe(false);\n    });\n\n    it('should identify retryable errors', () => {\n      const retryableError = new NetworkError('Timeout', 408);\n      retryableError.isRetryable = true;\n      expect(ErrorUtils.canRetry(retryableError)).toBe(true);\n\n      const nonRetryableError = new ValidationError('Invalid input');\n      expect(ErrorUtils.canRetry(nonRetryableError)).toBe(false);\n    });\n\n    it('should identify user input errors', () => {\n      const inputError = new ValidationError('Invalid address');\n      expect(ErrorUtils.isUserInputError(inputError)).toBe(true);\n\n      const networkError = new NetworkError('Connection failed');\n      expect(ErrorUtils.isUserInputError(networkError)).toBe(false);\n    });\n\n    it('should extract validation field names', () => {\n      const addressError = new ValidationError('Invalid Bitcoin address format');\n      expect(ErrorUtils.getValidationField(addressError)).toBe('address');\n\n      const dateError = new ValidationError('Invalid vesting start date');\n      expect(ErrorUtils.getValidationField(dateError)).toBe('date');\n\n      const amountError = new ValidationError('Invalid grant amount');\n      expect(ErrorUtils.getValidationField(amountError)).toBe('amount');\n\n      const genericError = new ValidationError('Something is wrong');\n      expect(ErrorUtils.getValidationField(genericError)).toBeNull();\n    });\n  });\n});\n\ndescribe('Custom Error Classes', () => {\n  describe('OnChainTrackingError', () => {\n    it('should create error with all properties', () => {\n      const error = new OnChainTrackingError(\n        'Test error',\n        'TEST_ERROR',\n        true,\n        'User friendly message',\n        'Do this to fix it'\n      );\n\n      expect(error.name).toBe('OnChainTrackingError');\n      expect(error.message).toBe('Test error');\n      expect(error.code).toBe('TEST_ERROR');\n      expect(error.isRetryable).toBe(true);\n      expect(error.userFriendlyMessage).toBe('User friendly message');\n      expect(error.actionableGuidance).toBe('Do this to fix it');\n    });\n  });\n\n  describe('ValidationError', () => {\n    it('should create validation error with field', () => {\n      const error = new ValidationError('Invalid format', 'address');\n      \n      expect(error.code).toBe('VALIDATION_ERROR');\n      expect(error.isRetryable).toBe(false);\n      expect(error.userFriendlyMessage).toContain('Invalid address');\n      expect(error.actionableGuidance).toContain('correct the address');\n    });\n\n    it('should create validation error without field', () => {\n      const error = new ValidationError('Invalid format');\n      \n      expect(error.userFriendlyMessage).toContain('Invalid input');\n      expect(error.actionableGuidance).toContain('correct the input');\n    });\n  });\n\n  describe('NetworkError', () => {\n    it('should mark retryable status codes as retryable', () => {\n      const timeoutError = new NetworkError('Timeout', 408);\n      expect(timeoutError.isRetryable).toBe(true);\n\n      const rateLimitError = new NetworkError('Rate limited', 429);\n      expect(rateLimitError.isRetryable).toBe(true);\n\n      const serverError = new NetworkError('Server error', 500);\n      expect(serverError.isRetryable).toBe(true);\n    });\n\n    it('should mark non-retryable status codes as non-retryable', () => {\n      const badRequestError = new NetworkError('Bad request', 400);\n      expect(badRequestError.isRetryable).toBe(false);\n\n      const notFoundError = new NetworkError('Not found', 404);\n      expect(notFoundError.isRetryable).toBe(false);\n    });\n\n    it('should default to retryable when no status code provided', () => {\n      const genericError = new NetworkError('Network error');\n      expect(genericError.isRetryable).toBe(true);\n    });\n  });\n\n  describe('DataProcessingError', () => {\n    it('should create processing error with step', () => {\n      const error = new DataProcessingError('Failed to parse', 'annotation');\n      \n      expect(error.code).toBe('DATA_PROCESSING_ERROR');\n      expect(error.isRetryable).toBe(false);\n      expect(error.userFriendlyMessage).toContain('processing annotation');\n      expect(error.actionableGuidance).toContain('verify your inputs');\n    });\n  });\n\n  describe('PartialDataError', () => {\n    it('should create partial data error with details', () => {\n      const error = new PartialDataError(\n        'Some data missing',\n        'transactions',\n        'price data'\n      );\n      \n      expect(error.code).toBe('PARTIAL_DATA_ERROR');\n      expect(error.isRetryable).toBe(true);\n      expect(error.userFriendlyMessage).toContain('price data');\n      expect(error.actionableGuidance).toContain('continue with partial data');\n    });\n  });\n});\n\ndescribe('Integration Tests', () => {\n  let errorHandler: OnChainErrorHandler;\n\n  beforeEach(() => {\n    errorHandler = OnChainErrorHandler.getInstance();\n  });\n\n  it('should handle complete error flow with retry and recovery', async () => {\n    let callCount = 0;\n    const mockOperation = jest.fn().mockImplementation(async () => {\n      callCount++;\n      \n      if (callCount === 1) {\n        // First call: network timeout (retryable)\n        throw new Error('Request timeout');\n      } else if (callCount === 2) {\n        // Second call: rate limit (retryable)\n        const rateLimitError = new MempoolAPIError('Rate limit exceeded', 429, true);\n        throw rateLimitError;\n      } else {\n        // Third call: success\n        return { success: true, data: 'test data' };\n      }\n    });\n\n    const result = await errorHandler.executeWithRetry(\n      mockOperation,\n      {\n        operation: 'transaction_fetch',\n        step: 'fetch_transactions',\n        address: 'test-address',\n        timestamp: '2024-01-01T00:00:00.000Z'\n      },\n      {\n        maxRetries: 3,\n        baseDelay: 10,\n        maxDelay: 100,\n        exponentialBackoff: false,\n        retryableErrors: ['NETWORK_ERROR']\n      }\n    );\n\n    expect(result).toEqual({ success: true, data: 'test data' });\n    expect(mockOperation).toHaveBeenCalledTimes(3);\n  });\n\n  it('should handle graceful degradation scenario', () => {\n    const partialData = {\n      transactions: [\n        { txid: '1', amount: 0.1 },\n        { txid: '2', amount: 0.2 }\n      ]\n    };\n\n    const result = errorHandler.handlePartialDataError(\n      partialData,\n      'historical USD prices',\n      {\n        operation: 'price_fetch',\n        step: 'fetch_historical_prices',\n        timestamp: '2024-01-01T00:00:00.000Z'\n      }\n    );\n\n    expect(result.data).toEqual(partialData);\n    expect(result.error).toBeInstanceOf(PartialDataError);\n    \n    const userFriendly = errorHandler.createUserFriendlyError(result.error);\n    expect(userFriendly.title).toBe('Partial Results');\n    expect(userFriendly.canRetry).toBe(true);\n  });\n});\n